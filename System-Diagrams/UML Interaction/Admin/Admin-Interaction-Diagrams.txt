@startuml
title Create Offering and Assign to Branches
actor Admin
participant "System\n<<singleton>>" as System
participant "OfferingCatalog\n<<singleton>>" as OfferingCatalog
participant "O:Offering" as Offering
collections "Offerings" as Offerings
collections "OfferedInBranch" as OfferedInBranch

note right of System
Not showing error scenarios
end note

autonumber

Admin -> System: startCreateOffering(*args, List<branch_id>)
System -> System: validateAdminAccess()
System -> System: generateId()
note right: System generates unique ID

System -> OfferingCatalog: getInstance()
System -> OfferingCatalog: createOffering(id, *args)
OfferingCatalog -> Offering **: create(id, *args)
Offering --> OfferingCatalog: confirm
OfferingCatalog -> Offerings: add(O)
Offerings --> OfferingCatalog: confirm

loop#lightblue #lightblue for each branch_id in branch_ids
    System -> OfferedInBranch: add(branch_id, offering_id)
    OfferedInBranch --> System: confirm
end

System --> Admin: confirm
@enduml
______________________________

@startuml
title Create Location
actor Admin
participant "System\n<<singleton>>" as System
participant "LocationCatalog\n<<singleton>>" as LocationCatalog
participant "L:Location" as Location

note over LocationCatalog
Location is a generic type representing
all location subtypes (Province, City, Branch)
end note

note right of System
parent_location_id may be null (for Province)
*args used for brevity
end note

autonumber

Admin -> System: createLocation(parent_location_id, *args)
System -> System: validateAdminAccess()
System -> System: generateId()
note right: System generates unique ID

System -> LocationCatalog: getInstance()
System -> LocationCatalog: addLocation(id, parent_location_id, *args)
LocationCatalog -> Location **: create(id, parent_location_id, *args)
LocationCatalog -> LocationCatalog: validateLocationHierarchy(L)
Location --> LocationCatalog: confirm
System --> Admin: confirm
@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "UserCatalog\n<<singleton>>" as UserCatalog
participant "U:User" as User

note over UI
Generic User type encompassesboth Client and Instructor

Abstracting off error handling
end note

title Delete User

autonumber

Admin -> UI: handleUserInput(user_id)
UI -> System: deleteUser(id)
System -> System: validateAdminAccess()
System -> UserCatalog: getInstance()
System -> UserCatalog: getUser(id)
UserCatalog -> UserCatalog: find(id)
UserCatalog --> System: return U:User
System -> User !!: delete
System --> UI: confirm
UI --> Admin: confirm

@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "UserCatalog\n<<singleton>>" as UserCatalog
participant "U:User" as User

note over UI
Using generic user notation
We also assume absence of errors 
end note

title Edit User

autonumber

Admin -> UI: handleUserInput(user_id, *args)
UI -> System: editUser(id, *args)

System -> System: validateAdminAccess()
System -> UserCatalog: getInstance()
System -> UserCatalog: getUser(id)
UserCatalog -> UserCatalog: find(id)
UserCatalog --> System: return U:User

System -> User: updateProfile(*args)
User --> System: confirm
System --> UI: confirm
UI --> Admin: confirm
@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "BookingCatalog\n<<singleton>>" as BookingCatalog
participant "B:Booking" as Booking

title Delete Booking
note over UI
Abstracting off error handling and omitting user notification
end note

autonumber

Admin -> UI: handleUserInput(booking_id)
UI -> System: deleteBooking(id)

    System -> System: validateAdminAccess()
    System -> BookingCatalog: getInstance()
    System -> BookingCatalog: getBooking(id)
    BookingCatalog -> BookingCatalog: find(id)
    BookingCatalog --> System: return B:Booking
    System -> Booking !!: delete
    System --> UI: confirm
    UI --> Admin: confirm

@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "BookingCatalog\n<<singleton>>" as BookingCatalog
participant "B:Booking" as Booking

title Edit Booking

note over UI
Abstracting off error handling
end note

autonumber

Admin -> UI: handleUserInput(booking_id, *args)
UI -> System: editBooking(id, *args)

System -> System: validateAdminAccess()
System -> BookingCatalog: getInstance()
System -> BookingCatalog: getBooking(id)
BookingCatalog -> BookingCatalog: find(id)
BookingCatalog --> System: return B:Booking

System -> Booking: editRecord(*args)
Booking --> System: confirm
System --> UI: confirm
UI --> Admin: confirm
@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "OfferingCatalog\n<<singleton>>" as OfferingCatalog
participant "O:Offering" as Offering

title Delete Base Offering

note over UI
Assuming all records exist and are valid
end note

autonumber

Admin -> UI: handleUserInput(offering_id)
UI -> System: deleteOffering(id)

System -> System: validateAdminAccess()
System -> OfferingCatalog: getInstance()
System -> OfferingCatalog: getOffering(id)
OfferingCatalog -> OfferingCatalog: find(id)
OfferingCatalog --> System: return O:Offering
System -> Offering !!: delete
System --> UI: confirm
UI --> Admin: confirm
@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "OfferingCatalog\n<<singleton>>" as OfferingCatalog
participant "BookingCatalog\n<<singleton>>" as BookingCatalog
participant "PO:PublicOffering" as PublicOffering
participant "B:Booking" as Booking

title Delete Public Offering

note over UI
Assuming all records exist and are valid
Omitting user notifications
end note

autonumber

Admin -> UI: handleUserInput(public_offering_id)
UI -> System: deletePublicOffering(id)

System -> System: validateAdminAccess()
System -> OfferingCatalog: getInstance()
System -> OfferingCatalog: getPublicOffering(id)
OfferingCatalog -> OfferingCatalog: find(id)
OfferingCatalog --> System: return PO:PublicOffering

System -> BookingCatalog: getInstance()
System -> BookingCatalog: getBookingsByOffering(id)
BookingCatalog -> BookingCatalog: find(id)
BookingCatalog --> System: return List<Booking>

loop#e6e6fa #e6e6fa for each booking in List<Booking>
    System -> Booking !!: delete
end

System -> PublicOffering !!: delete
System --> UI: confirm
UI --> Admin: confirm
@enduml
______________________________

@startuml
actor Admin
participant UI
participant "System\n<<singleton>>" as System
participant "OfferingCatalog\n<<singleton>>" as OfferingCatalog
participant "O:Offering" as Offering

note over OfferingCatalog
Generic Offering type encompasses
both Public and Base Offerings
Abstracting off error handling
end note

title Edit Offering

autonumber

Admin -> UI: handleUserInput(offering_id, *args)
UI -> System: editOffering(id, *args)

System -> System: validateAdminAccess()
System -> OfferingCatalog: getInstance()
System -> OfferingCatalog: getOffering(id)
OfferingCatalog -> OfferingCatalog: find(id)
OfferingCatalog --> System: return O:Offering

System -> Offering: editRecord(*args)
Offering --> System: confirm
System --> UI: confirm
UI --> Admin: confirm
@enduml
______________________________
